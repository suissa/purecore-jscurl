# ExplicaÃ§Ã£o Detalhada: ImplementaÃ§Ã£o de Sobrecarga de FunÃ§Ãµes

## ğŸ“š Conceito de Sobrecarga em TypeScript

TypeScript suporta **sobrecarga de funÃ§Ãµes** (function overloading), que permite definir mÃºltiplas assinaturas para a mesma funÃ§Ã£o. Isso Ã© diferente de linguagens como Java ou C++, onde vocÃª realmente cria mÃºltiplas funÃ§Ãµes. No TypeScript, vocÃª define as assinaturas na interface/tipo e implementa uma Ãºnica funÃ§Ã£o que trata todos os casos.

## ğŸ¯ O Problema que Resolvemos

A biblioteca `r3q` precisa suportar duas formas de uso, similar ao Axios:

```typescript
// Forma 1: URL como primeiro parÃ¢metro
r3q('https://api.example.com/users', { method: 'GET' })

// Forma 2: Config completo com URL dentro
r3q({ url: 'https://api.example.com/users', method: 'GET' })
```

## ğŸ”§ Como Foi Implementado

### 1. DefiniÃ§Ã£o das Assinaturas na Interface

Primeiro, definimos as duas assinaturas possÃ­veis na interface `R3qInstance`:

```28:30:src/types.ts
export interface R3qInstance {
  (config: R3qRequestConfig): Promise<R3qResponse>;
  (url: string, config?: R3qRequestConfig): Promise<R3qResponse>;
```

**O que isso significa:**
- **Primeira assinatura:** `(config: R3qRequestConfig)` - Recebe apenas um objeto de configuraÃ§Ã£o que deve conter a URL
- **Segunda assinatura:** `(url: string, config?: R3qRequestConfig)` - Recebe URL como string e um config opcional

O TypeScript usa essas assinaturas para:
- âœ… Autocomplete no IDE
- âœ… VerificaÃ§Ã£o de tipos em tempo de compilaÃ§Ã£o
- âœ… IntelliSense mostrando as duas opÃ§Ãµes

### 2. ImplementaÃ§Ã£o da FunÃ§Ã£o Ãšnica

Na implementaÃ§Ã£o, criamos **uma Ãºnica funÃ§Ã£o** que aceita ambos os formatos:

```16:34:src/index.ts
  const request = async function (
    urlOrConfig: string | R3qRequestConfig,
    config?: R3qRequestConfig
  ): Promise<R3qResponse> {
    // Suporte para sobrecarga: (url, config?) ou (config)
    let url: string;
    let finalConfig: R3qRequestConfig;

    if (typeof urlOrConfig === "string") {
      url = urlOrConfig;
      finalConfig = config || {};
    } else {
      finalConfig = urlOrConfig;
      const configWithUrl = finalConfig as R3qRequestConfig & { url?: string | Url };
      url = (configWithUrl.url ? String(configWithUrl.url) : "") || "";
      if (!url) {
        throw new Error("URL is required");
      }
    }
```

## ğŸ” AnÃ¡lise Passo a Passo

### Passo 1: Assinatura da FunÃ§Ã£o

```typescript
urlOrConfig: string | R3qRequestConfig,
config?: R3qRequestConfig
```

- `urlOrConfig` pode ser **string** (quando URL vem primeiro) ou **R3qRequestConfig** (quando tudo vem no config)
- `config` Ã© **opcional** porque sÃ³ Ã© usado quando `urlOrConfig` Ã© string

### Passo 2: Pattern Matching em Runtime

```typescript
if (typeof urlOrConfig === "string") {
  // CASO 1: r3q('https://...', { method: 'GET' })
  url = urlOrConfig;           // Primeiro parÃ¢metro Ã© a URL
  finalConfig = config || {};  // Segundo parÃ¢metro Ã© o config (ou vazio)
} else {
  // CASO 2: r3q({ url: 'https://...', method: 'GET' })
  finalConfig = urlOrConfig;   // Primeiro parÃ¢metro Ã© o config completo
  url = finalConfig.url;        // ExtraÃ­mos a URL do config
}
```

### Passo 3: ValidaÃ§Ã£o

```typescript
if (!url) {
  throw new Error("URL is required");
}
```

Garantimos que sempre teremos uma URL vÃ¡lida, mesmo que venha de formas diferentes.

## ğŸ¨ Type Assertion NecessÃ¡ria

Note que usamos um type assertion aqui:

```typescript
const configWithUrl = finalConfig as R3qRequestConfig & { url?: string | Url };
```

**Por quÃª?**
- O TypeScript nÃ£o consegue inferir automaticamente que `finalConfig.url` existe
- Mesmo tendo adicionado `url?: string | Url` na interface, o TypeScript pode nÃ£o reconhecer em todos os contextos
- O type assertion `as R3qRequestConfig & { url?: string | Url }` ajuda o compilador a entender que podemos acessar `url`

## ğŸ”„ Como os MÃ©todos HTTP Usam a Sobrecarga

Os mÃ©todos auxiliares (`get`, `post`, etc.) sempre usam a **segunda assinatura** (URL primeiro):

```115:116:src/index.ts
  request.get = (url, config) =>
    request(url, { ...config, method: "GET" as HttpMethod });
```

Isso significa:
- `r3q.get('https://...', { headers: {...} })` â†’ chama `request('https://...', { headers: {...}, method: 'GET' })`
- O TypeScript sabe que `url` Ã© string e `config` Ã© opcional
- Internamente, sempre cai no primeiro `if` (porque `urlOrConfig` Ã© string)

## ğŸ“Š Fluxograma de DecisÃ£o

```
Chamada da funÃ§Ã£o
       â”‚
       â”œâ”€ r3q('https://...', config?)
       â”‚   â””â”€ typeof urlOrConfig === "string" âœ…
       â”‚       â””â”€ url = urlOrConfig
       â”‚       â””â”€ finalConfig = config || {}
       â”‚
       â””â”€ r3q({ url: 'https://...', method: 'GET' })
           â””â”€ typeof urlOrConfig === "object" âœ…
               â””â”€ finalConfig = urlOrConfig
               â””â”€ url = finalConfig.url
               â””â”€ ValidaÃ§Ã£o: url existe?
```

## ğŸ¯ Vantagens Desta Abordagem

1. **Flexibilidade:** UsuÃ¡rio escolhe o estilo que prefere
2. **Type Safety:** TypeScript valida ambos os formatos
3. **Compatibilidade:** Similar ao Axios, facilitando migraÃ§Ã£o
4. **Performance:** Zero overhead - apenas uma verificaÃ§Ã£o `typeof` em runtime
5. **Manutenibilidade:** Uma Ãºnica implementaÃ§Ã£o para manter

## ğŸ”¬ Exemplo PrÃ¡tico de Uso

```typescript
// Forma 1: URL primeiro (mais comum)
const response1 = await r3q('https://api.example.com/users', {
  headers: { 'Authorization': 'Bearer token' }
});

// Forma 2: Config completo (mais verboso, mas Ãºtil para casos complexos)
const response2 = await r3q({
  url: 'https://api.example.com/users',
  method: 'GET',
  headers: { 'Authorization': 'Bearer token' },
  params: { page: 1, limit: 10 }
});

// Ambos funcionam! ğŸ‰
```

## ğŸ§  Conceitos TypeScript Utilizados

1. **Union Types:** `string | R3qRequestConfig`
2. **Optional Parameters:** `config?: R3qRequestConfig`
3. **Type Guards:** `typeof urlOrConfig === "string"`
4. **Type Assertions:** `as R3qRequestConfig & { url?: string | Url }`
5. **Function Overloads:** MÃºltiplas assinaturas na interface

## ğŸ“ Resumo

A sobrecarga foi implementada usando:
- âœ… **Interface com mÃºltiplas assinaturas** para type checking
- âœ… **Uma Ãºnica funÃ§Ã£o** com union types para aceitar ambos os formatos
- âœ… **Pattern matching em runtime** usando `typeof` para detectar qual formato foi usado
- âœ… **Type assertions** quando necessÃ¡rio para ajudar o TypeScript
- âœ… **ValidaÃ§Ã£o** para garantir que sempre temos uma URL vÃ¡lida

Esta Ã© uma implementaÃ§Ã£o padrÃ£o e eficiente de sobrecarga em TypeScript, balanceando type safety com flexibilidade de uso!
